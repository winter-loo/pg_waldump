#![allow(unused)]
use nom::bytes::streaming::take as bytes_take;
use nom::combinator::map;
use nom::number::streaming::{le_u16, le_u32, le_u64, le_u8};
use nom::sequence;
use nom::IResult;
use std::io::Read;
use std::mem::size_of;
mod constant;
use constant::*;
mod pg_types;
use pg_types::*;
use std::path::PathBuf;

use clap::Parser;

fn verify_directory(p: &str) -> Result<std::path::PathBuf, String> {
    let path = std::path::PathBuf::from(p);
    if path.is_dir() {
        Ok(path)
    } else {
        Err(format!("no such directory: {}", path.display()))
    }
}

fn parse_lsn(s: &str) -> Result<XLogRecPtr, String> {
    let parts: Vec<&str> = s.split("/").collect();
    if parts.len() != 2 {
        return Err(format!("invalid WAL location: {}", s));
    }
    let xlogid = match u64::from_str_radix(parts[0], 16) {
        Ok(t) => t,
        Err(_) => {
            return Err(format!("invalid WAL location: {}", s));
        }
    };
    let xrecoff = match u64::from_str_radix(parts[1], 16) {
        Ok(t) => t,
        Err(_) => {
            return Err(format!("invalid WAL location: {}", s));
        }
    };
    Ok(xlogid << 32 | xrecoff)
}

/// pg_waldump decodes and displays PostgreSQL write-ahead logs for debugging.
#[derive(Parser)]
#[command(author, version, about, long_about = None, disable_colored_help=true,
help_template="\
{about-with-newline}
{usage-heading}
  {usage}

Options:
{options}
")]
struct Cli {
    startseg: Option<PathBuf>,
    endseg: Option<PathBuf>,

    /// output detailed information about backup blocks
    #[arg(short, long, action=clap::ArgAction::SetTrue)]
    bkp_details: Option<bool>,

    /// with --relation, only show records that modify block N
    #[arg(short = 'B', long, value_name = "N")]
    block: Option<u32>,

    /// start reading at WAL location RECPTR
    #[arg(short, long, value_name = "RECPTR", value_parser=parse_lsn)]
    start: Option<XLogRecPtr>,

    /// stop reading at WAL location RECPTR
    #[arg(short, long, value_name = "RECPTR", value_parser=parse_lsn)]
    end: Option<XLogRecPtr>,

    /// keep retrying after reaching end of WAL
    #[arg(short, long, action=clap::ArgAction::SetTrue)]
    follow: Option<bool>,

    #[arg(
        short = 'F',
        long,
        value_name = "FORK",
        value_parser=[
            "main",
            "fsm",
            "vm",
            "init",
        ],
        hide_possible_values=true,
        help = "\
only show records that modify blocks in fork FORK;
valid names are main, fsm, vm, init"
    )]
    fork: Option<String>,

    /// number of records to display
    #[arg(short = 'n', long, value_name = "N")]
    limit: Option<u32>,

    #[arg(
        short,
        long,
        value_parser=verify_directory,
        hide_default_value=true,
        help = "\
directory in which to find log segment files or a
directory with a ./pg_wal that contains such files
(default: current directory, ./pg_wal, $PGDATA/pg_wal)"
    )]
    path: Option<PathBuf>,

    /// do not print any output, except for errors
    #[arg(short, long, action=clap::ArgAction::SetTrue)]
    quiet: Option<bool>,

    #[arg(
        short,
        long,
        help = "\
only show records generated by resource manager RMGR;
use --rmgr=list to list valid resource manager names"
    )]
    rmgr: Option<String>,

    /// only show records that modify blocks in relation T/D/R
    #[arg(short = 'R', long, value_name = "T/D/R")]
    relation: Option<String>,

    #[arg(
        short,
        long,
        value_name = "TLI",
        default_value = "1",
        hide_default_value = true,
        help = "\
timeline from which to read log records
(default: 1 or the value used in STARTSEG)"
    )]
    timeline: Option<TimeLineID>,

    /// only show records with a full page write
    #[arg(short='w', long, action=clap::ArgAction::SetTrue)]
    fullpage: Option<bool>,

    /// only show records with transaction ID XID
    #[arg(short, long)]
    xid: Option<String>,

    #[arg(
        short = 'z',
        long,
        value_name = "record",
        help = "\
show statistics instead of records
(optionally, show per-record statistics)"
    )]
    // this is an optional argument and the argument value is also optional
    stats: Option<Option<String>>,
}

#[repr(align(8))]
struct XLogPageHeaderData {
    xlp_magic: u16,
    xlp_info: u16,
    xlp_tli: TimeLineID,
    xlp_paguaddr: XLogRecPtr,
    // When there is not enough space on current page for whole record, we
    // continue on the next page.  xlp_rem_len is the number of bytes
    // remaining from a previous page.
    //
    // Note that xlp_rem_len includes backup-block data; that is, it tracks
    // xl_tot_len not xl_len in the initial header.  Also note that the
    // continuation data isn't necessarily aligned.
    xlp_rem_len: u32,
}

impl XLogPageHeaderData {
    fn new() -> Self {
        XLogPageHeaderData {
            xlp_magic: XLOG_PAGE_MAGIC,
            xlp_info: 0,
            xlp_tli: 0,
            xlp_paguaddr: 0,
            xlp_rem_len: 0,
        }
    }
}

fn page_header(input: &[u8]) -> IResult<&[u8], XLogPageHeaderData> {
    map(
        sequence::tuple((le_u16, le_u16, le_u32, le_u64, le_u32, bytes_take(4usize))),
        |(magic, info, tli, paguaddr, rem_len, _)| {
            if magic != XLOG_PAGE_MAGIC {
                panic!("invalid magic: {:#06X}", magic);
            }
            XLogPageHeaderData {
                xlp_magic: XLOG_PAGE_MAGIC,
                xlp_info: info,
                xlp_tli: tli,
                xlp_paguaddr: paguaddr,
                xlp_rem_len: rem_len,
            }
        },
    )(input)
}

#[repr(align(8))]
struct XLogLongPageHeaderData {
    std: XLogPageHeaderData,
    xlp_sysid: u64,
    xlp_seg_size: u32,
    xlp_xlog_blcksz: u32,
}

fn first_page_header(input: &[u8]) -> IResult<&[u8], XLogLongPageHeaderData> {
    map(
        sequence::tuple((page_header, le_u64, le_u32, le_u32)),
        |(hdr, sysid, seg_size, blcksz)| XLogLongPageHeaderData {
            std: hdr,
            xlp_sysid: sysid,
            xlp_seg_size: seg_size,
            xlp_xlog_blcksz: blcksz,
        },
    )(input)
}

#[repr(align(8))]
struct XLogRecord {
    // total len of entire record
    xl_tot_len: u32,
    // xact id
    xl_xid: TransactionId,
    // ptr to previous record in log
    xl_prev: XLogRecPtr,
    // flag bits, see below
    xl_info: u8,
    // resource manager for this record
    xl_rmid: RmgrId,
    // CRC for this record
    xl_crc: PgCrc32c,
    // XLogRecordBlockHeaders and XLogRecordDataHeader follow, no padding
}

fn xlog_record(input: &[u8]) -> IResult<&[u8], XLogRecord> {
    map(
        sequence::tuple((
            le_u32,
            le_u32,
            le_u64,
            le_u8,
            le_u8,
            bytes_take(2usize),
            le_u32,
        )),
        |(tot_len, xid, prev, info, rmid, _, crc)| XLogRecord {
            xl_tot_len: tot_len,
            xl_xid: xid,
            xl_prev: prev,
            xl_info: info,
            xl_rmid: rmid,
            xl_crc: crc,
        },
    )(input)
}

#[derive(PartialEq, Debug)]
enum XLogRecordDataHeader {
    Short(XLogRecordDataHeaderShort),
    Long(XLogRecordDataHeaderLong),
    Origin(XLogRecordDataHeaderOrigin),
    TopLevelXid(XLogRecordDataHeaderTopLevelXid),
    Block(XLogRecordBlockHeader),
}

fn xlog_record_data_header(input: &[u8]) -> IResult<&[u8], XLogRecordDataHeader> {
    let (input, id) = le_u8(input)?;
    match id {
        XLR_BLOCK_ID_DATA_SHORT => map(xlog_record_data_header_short(id), |hdr| {
            XLogRecordDataHeader::Short(hdr)
        })(input),
        XLR_BLOCK_ID_DATA_LONG => map(xlog_record_data_header_long(id), |hdr| {
            XLogRecordDataHeader::Long(hdr)
        })(input),
        XLR_BLOCK_ID_ORIGIN => map(xlog_record_data_header_origin(id), |hdr| {
            XLogRecordDataHeader::Origin(hdr)
        })(input),
        XLR_BLOCK_ID_TOPLEVEL_XID => map(xlog_record_data_header_top_level_xid(id), |hdr| {
            XLogRecordDataHeader::TopLevelXid(hdr)
        })(input),
        val if val <= XLR_MAX_BLOCK_ID => map(xlog_record_block_header(id), |hdr| {
            XLogRecordDataHeader::Block(hdr)
        })(input),
        _ => panic!("invalid XLogRecordDataHeader id: {}", id),
    }
}

// XLogRecordDataHeaderShort/Long are used for the "main data" portion of
// the record. If the length of the data is less than 256 bytes, the short
// form is used, with a single byte to hold the length. Otherwise the long
// form is used.
#[repr(packed)]
#[derive(PartialEq, Debug)]
struct XLogRecordDataHeaderShort {
    // XLR_BLOCK_ID_DATA_SHORT
    id: u8,
    // number of payload bytes
    data_length: u8,
}

fn xlog_record_data_header_short(
    id: u8,
) -> impl FnMut(&[u8]) -> IResult<&[u8], XLogRecordDataHeaderShort> {
    move |input: &[u8]| {
        let (input, data_length) = le_u8(input)?;
        Ok((input, XLogRecordDataHeaderShort { id, data_length }))
    }
}

#[repr(packed)]
#[derive(PartialEq, Debug)]
struct XLogRecordDataHeaderLong {
    // XLR_BLOCK_ID_DATA_LONG
    id: u8,
    data_length: u32,
}

fn xlog_record_data_header_long(
    id: u8,
) -> impl FnMut(&[u8]) -> IResult<&[u8], XLogRecordDataHeaderLong> {
    move |input: &[u8]| {
        let (input, data_length) = le_u32(input)?;
        Ok((input, XLogRecordDataHeaderLong { id, data_length }))
    }
}

#[repr(packed)]
#[derive(PartialEq, Debug)]
struct XLogRecordDataHeaderOrigin {
    id: u8,
    record_origin: u16,
}

fn xlog_record_data_header_origin(
    id: u8,
) -> impl FnMut(&[u8]) -> IResult<&[u8], XLogRecordDataHeaderOrigin> {
    move |input: &[u8]| {
        let (input, record_origin) = le_u16(input)?;
        Ok((input, XLogRecordDataHeaderOrigin { id, record_origin }))
    }
}

#[repr(packed)]
#[derive(PartialEq, Debug)]
struct XLogRecordDataHeaderTopLevelXid {
    id: u8,
    top_level_xid: TransactionId,
}

fn xlog_record_data_header_top_level_xid(
    id: u8,
) -> impl FnMut(&[u8]) -> IResult<&[u8], XLogRecordDataHeaderTopLevelXid> {
    move |input: &[u8]| {
        let (input, top_level_xid) = le_u32(input)?;
        Ok((input, XLogRecordDataHeaderTopLevelXid { id, top_level_xid }))
    }
}

// Header info for block data appended to an XLOG record.
//
// 'data_length' is the length of the rmgr-specific payload data associated
// with this block. It does not include the possible full page image, nor
// XLogRecordBlockHeader struct itself.
//
// Note that we don't attempt to align the XLogRecordBlockHeader struct!
// So, the struct must be copied to aligned local storage before use.
///
#[repr(packed)]
#[derive(PartialEq, Debug)]
struct XLogRecordBlockHeader {
    // block reference ID
    id: u8,
    // fork within the relation, and flags
    fork_flags: u8,
    // number of payload bytes (not including page image)
    data_length: u16,
    // If BKPBLOCK_HAS_IMAGE, an XLogRecordBlockImageHeader struct follows
    // If BKPBLOCK_SAME_REL is not set, a RelFileNode follows
    // BlockNumber follows
}

fn xlog_record_block_header(id: u8) -> impl FnMut(&[u8]) -> IResult<&[u8], XLogRecordBlockHeader> {
    move |input: &[u8]| {
        map(
            sequence::tuple((le_u8, le_u16)),
            |(fork_flags, data_length)| XLogRecordBlockHeader {
                id,
                fork_flags,
                data_length,
            },
        )(input)
    }
}

struct RelFileNode {
    // tablespace
    spc_node: u32,
    // database
    db_node: u32,
    // relation
    rel_node: u32,
}

fn rel_file_node(input: &[u8]) -> IResult<&[u8], RelFileNode> {
    map(
        sequence::tuple((le_u32, le_u32, le_u32)),
        |(spc_node, db_node, rel_node)| RelFileNode {
            spc_node,
            db_node,
            rel_node,
        },
    )(input)
}

#[repr(packed)]
struct XLogRecordBlockImageHeader {
    // number of page image bytes
    length: u16,
    // number of bytes before "hole"
    hole_offset: u16,
    // flag bits, see below
    bimg_info: u8,
    // If BKPIMAGE_HAS_HOLE and BKPIMAGE_IS_COMPRESSED, an
    // XLogRecordBlockCompressHeader struct follows.
}

fn xlog_record_block_image_header(input: &[u8]) -> IResult<&[u8], XLogRecordBlockImageHeader> {
    map(
        sequence::tuple((le_u16, le_u16, le_u8)),
        |(length, hole_offset, bimg_info)| XLogRecordBlockImageHeader {
            length,
            hole_offset,
            bimg_info,
        },
    )(input)
}

fn xlog_block_number(input: &[u8]) -> IResult<&[u8], BlockNumber> {
    le_u32(input)
}

struct XLogRecordBlockCompressHeader {
    // number of bytes in "hole"
    hole_length: u16,
}

fn xlog_page_header_size(hdr: XLogPageHeaderData) -> usize {
    if hdr.xlp_info & XLP_LONG_HEADER != 0 {
        size_of::<XLogLongPageHeaderData>()
    } else {
        size_of::<XLogPageHeaderData>()
    }
}

fn search_directory(waldir: &std::path::PathBuf, fname: &std::path::PathBuf) -> bool {
    let mut srched = std::path::PathBuf::new();
    if fname.as_os_str().is_empty() {
        for de in std::fs::read_dir(waldir).unwrap() {
            let de = de.unwrap();
            let path = de.path();
            if path.is_file() && is_xlog_filename(&path) {
                srched = path;
                break;
            }
        }
    } else {
        srched = fname.clone();
    }
    if srched.as_os_str().is_empty() {
        panic!("no valid wal segment file found");
    }
    check_first_page_header(&waldir, &srched)
}

static mut WAL_SEG_SZ: u32 = 16 * 1024 * 1024;

fn unsafe_get_wal_seg_sz() -> u32 {
    unsafe { WAL_SEG_SZ }
}

fn unsafe_set_wal_seg_sz(sz: u32) {
    unsafe {
        WAL_SEG_SZ = sz;
    }
}

fn is_valid_wal_segment_size(sz: u32) -> bool {
    (sz > 0 && (sz & (sz - 1) == 0)) && sz >= WAL_SEG_MIN_SIZE && sz <= WAL_SEG_MAX_SIZE
}

fn check_first_page_header(waldir: &PathBuf, fname: &PathBuf) -> bool {
    let mut fpath = waldir.clone();
    fpath.push(fname);
    let mut file = std::fs::File::open(fpath).unwrap();

    let mut buf = [0u8; 8192];
    match file.read(&mut buf) {
        Ok(n) => {
            if n == XLOG_BLOCKSZ as usize {
                let (_, hdr) = first_page_header(&buf).unwrap();
                if !is_valid_wal_segment_size(hdr.xlp_seg_size) {
                    panic!("invalid wal segment size");
                }
                unsafe_set_wal_seg_sz(hdr.xlp_seg_size);
                return true;
            } else {
                panic!(
                    "could not read file {}: read {} of {}",
                    fname.display(),
                    n,
                    XLOG_BLOCKSZ
                );
            }
        }
        Err(e) => {
            panic!("could not read file {}: {}", fname.display(), e);
        }
    }
    return false;
}

fn identify_target_directory(waldir: PathBuf, fname: &PathBuf) -> PathBuf {
    if !waldir.as_os_str().is_empty() {
        if search_directory(&waldir, &fname) {
            return waldir;
        }

        let mut waldir = waldir.clone();
        waldir.push(XLOGDIR);
        if search_directory(&waldir, &fname) {
            return waldir;
        }
    } else {
        let dir = std::path::PathBuf::from(".");
        if search_directory(&dir, &fname) {
            return dir;
        }

        let dir = std::path::PathBuf::from(XLOGDIR);
        if search_directory(&dir, &fname) {
            return dir;
        }

        let datadir = std::env::var("PGDATA").unwrap();
        if !datadir.is_empty() {
            let mut dir = std::path::PathBuf::from(datadir);
            dir.push(XLOGDIR);
            if search_directory(&dir, &fname) {
                return dir;
            }
        }
    }

    if !fname.as_os_str().is_empty() {
        panic!("could not locate WAL file {}", fname.display());
    } else {
        panic!("could not find any WAL file");
    }
    // not reached
    std::path::PathBuf::new()
}

#[inline]
fn prefix_length(s: &str, set: &str) -> usize {
    s.chars().take_while(|&c| set.contains(c)).count()
}

#[inline]
fn is_xlog_filename(fname: &std::path::PathBuf) -> bool {
    fname.as_os_str().len() == XLOG_FNAME_LEN
        && prefix_length(fname.to_str().unwrap(), "0123456789ABCDEF") == XLOG_FNAME_LEN
}

#[inline]
fn xlog_segments_per_xlog_id(wal_seg_sz: u32) -> u32 {
    (0x100000000u64 / wal_seg_sz as u64) as u32
}

#[inline]
fn xlog_filename(fname: &mut PathBuf, tli: TimeLineID, log_seg_no: XLogSegNo, wal_seg_sz: u32) {
    let n = xlog_segments_per_xlog_id(wal_seg_sz) as u64;
    let s = format!(
        "{:08X}{:08X}{:08X}",
        tli,
        (log_seg_no / n) as u32,
        (log_seg_no % n) as u32
    );
    *fname = PathBuf::from(s);
}

struct XLogDumpPrivate {
    timeline: TimeLineID,
    startptr: XLogRecPtr,
    endptr: XLogRecPtr,
    endptr_reached: bool,
}

impl XLogDumpPrivate {
    fn new() -> Self {
        XLogDumpPrivate {
            timeline: 0,
            startptr: 0,
            endptr: 0,
            endptr_reached: false,
        }
    }
}

#[inline]
fn xlog_from_file_name(
    fname: &PathBuf,
    timeline: &mut TimeLineID,
    segno: &mut XLogSegNo,
    wal_seg_sz: u32,
) {
    let fname = fname.to_str().unwrap();
    *timeline = fname[0..8].parse::<u32>().unwrap();
    let log = fname[8..16].parse::<u64>().unwrap();
    let seg = fname[16..24].parse::<u64>().unwrap();
    *segno = log * (0x10000_0000u64 / wal_seg_sz as u64) + seg;
}

fn xlog_read_record() {}

fn xlog_show_record() {}

trait XLogReaderRoutine {
    // Data input callback
    //
    // This callback shall read at least reqLen valid bytes of the xlog page
    // starting at targetPagePtr, and store them in readBuf.  The callback
    // shall return the number of bytes read (never more than XLOG_BLCKSZ), or
    // -1 on failure.  The callback shall sleep, if necessary, to wait for the
    // requested bytes to become available.  The callback will not be invoked
    // again for the same page unless more than the returned number of bytes
    // are needed.
    //
    // targetRecPtr is the position of the WAL record we're reading.  Usually
    // it is equal to targetPagePtr + reqLen, but sometimes xlogreader needs
    // to read and verify the page or segment header, before it reads the
    // actual WAL record it's interested in.  In that case, targetRecPtr can
    // be used to determine which timeline to read the page from.
    //
    // The callback shall set ->seg.ws_tli to the TLI of the file the page was
    // read from.
    fn page_read(
        xlogreader: &mut XLogReaderState,
        targetPagePtr: XLogRecPtr,
        reqLen: int,
        targetRecPtr: XLogRecPtr,
        readBuf: &[u8],
    ) -> int;

    // Callback to open the specified WAL segment for reading.  ->seg.ws_file
    // shall be set to the file descriptor of the opened segment.  In case of
    // failure, an error shall be raised by the callback and it shall not
    // return.
    //
    // "nextSegNo" is the number of the segment to be opened.
    //
    // "tli" is an input/output argument. WALRead() uses it to pass the
    // timeline in which the new segment should be found, but the callback can
    // use it to return the TLI that it actually opened.
    fn segment_open(xlogreader: &mut XLogReaderState, nextSegNo: XLogSegNo, tli: &mut TimeLineID);

    // WAL segment close callback.  ->seg.ws_file shall be set to a negative
    // number.
    fn segment_close(xlogreader: &mut XLogReaderState);
}

#[derive(default)]
struct XLogReaderState {
    // System identifier of the xlog files we're about to read.  Set to zero
    // (the default value) if unknown or unimportant.
    system_identifier: u64,

    // Opaque data for callbacks to use.  Not used by XLogReader.
    // *private_data: void,

    // Start and end point of last record read.  EndRecPtr is also used as the
    // position to read next.  Calling XLogBeginRead() sets EndRecPtr to the
    // starting position and ReadRecPtr to invalid.
    //
    // start of last record read
    readRecPtr: XLogRecPtr,
    // end+1 of last record read
    endRecPtr: XLogRecPtr,

    // Decoded representation of current record
    //
    // Use XLogRecGet* functions to investigate the record; these fields
    // should not be accessed directly.
    //
    // currently decoded record
    decoded_record: &mut XLogRecord,

    // record's main data portion
    main_data: &[u8],
    // main data portion's length
    main_data_len: u32,
    // allocated size of the buffer
    main_data_bufsz: u32,

    record_origin: RepOriginId,

    // information about blocks referenced by the record
    blocks: [DecodedBkpBlock; XLR_MAX_BLOCK_ID + 1],

    // highest block_id in use (-1 if none)
    max_block_id: int,

    // Buffer for currently read page (XLOG_BLCKSZ bytes, valid up to at least
    // readLen bytes)
    readBuf: &[u8],
    readLen: u32,

    // last read XLOG position for data currently in readBuf
    segcxt: WALSegmentContext,
    seg: WALOpenSegment,
    segoff: u32,

    // beginning of prior page read, and its TLI.  Doesn't necessarily
    // correspond to what's in readBuf; used for timeline sanity checks.
    latestPagePtr: XLogRecPtr,
    latestPageTLI: TimeLineID,

    // beginning of the WAL record being read
    currRecPtr: XLogRecPtr,
    // timeline to read it from, 0 if a lookup is required
    currTLI: TimeLineID,

    // Safe point to read to in currTLI if current TLI is historical
    // (tliSwitchPoint) or InvalidXLogRecPtr if on current timeline.
    //
    // Actually set to the start of the segment containing the timeline switch
    // that ends currTLI's validity, not the LSN of the switch its self, since
    // we can't assume the old segment will be present.
    currTLIValidUntil: XLogRecPtr,

    // If currTLI is not the most recent known timeline, the next timeline to
    // read from when currTLIValidUntil is reached.
    nextTLI: TimeLineID,

    // Buffer for current ReadRecord result (expandable), used when a record
    // crosses a page boundary.
    readRecordBuf: &[u8],
    readRecordBufSize: u32,

    // Buffer to hold error message
    errormsg_buf: String,

    // Set at the end of recovery: the start point of a partial record at the
    // end of WAL (InvalidXLogRecPtr if there wasn't one), and the start
    // location of its first contrecord that went missing.
    abortedRecPtr: XLogRecPtr,
    missingContrecPtr: XLogRecPtr,
    // Set when XLP_FIRST_IS_OVERWRITE_CONTRECORD is found
    overwrittenRecPtr: XLogRecPtr,
}

fn xlog_find_next_record(state: &mut XLogReaderState, rec_ptr: XLogRecPtr) -> XLogRecPtr {

	assert_eq!(!xlog_recptr_is_invalid(rec_ptr));

	// Make sure ReadPageInternal() can't return XLREAD_WOULDBLOCK
	state.nonblocking = false;

	/*
	 * skip over potential continuation data, keeping in mind that it may span
	 * multiple pages
	 */
	tmpRecPtr = RecPtr;
	while (true)
	{
		XLogRecPtr	targetPagePtr;
		int			targetRecOff;
		uint32		pageHeaderSize;
		int			readLen;

		/*
		 * Compute targetRecOff. It should typically be equal or greater than
		 * short page-header since a valid record can't start anywhere before
		 * that, except when caller has explicitly specified the offset that
		 * falls somewhere there or when we are skipping multi-page
		 * continuation record. It doesn't matter though because
		 * ReadPageInternal() is prepared to handle that and will read at
		 * least short page-header worth of data
		 */
		targetRecOff = tmpRecPtr % XLOG_BLCKSZ;

		/* scroll back to page boundary */
		targetPagePtr = tmpRecPtr - targetRecOff;

		/* Read the page containing the record */
		readLen = ReadPageInternal(state, targetPagePtr, targetRecOff);
		if (readLen < 0)
			goto err;

		header = (XLogPageHeader) state->readBuf;

		pageHeaderSize = XLogPageHeaderSize(header);

		/* make sure we have enough data for the page header */
		readLen = ReadPageInternal(state, targetPagePtr, pageHeaderSize);
		if (readLen < 0)
			goto err;

		/* skip over potential continuation data */
		if (header->xlp_info & XLP_FIRST_IS_CONTRECORD)
		{
			/*
			 * If the length of the remaining continuation data is more than
			 * what can fit in this page, the continuation record crosses over
			 * this page. Read the next page and try again. xlp_rem_len in the
			 * next page header will contain the remaining length of the
			 * continuation data
			 *
			 * Note that record headers are MAXALIGN'ed
			 */
			if (MAXALIGN(header->xlp_rem_len) >= (XLOG_BLCKSZ - pageHeaderSize))
				tmpRecPtr = targetPagePtr + XLOG_BLCKSZ;
			else
			{
				/*
				 * The previous continuation record ends in this page. Set
				 * tmpRecPtr to point to the first valid record
				 */
				tmpRecPtr = targetPagePtr + pageHeaderSize
					+ MAXALIGN(header->xlp_rem_len);
				break;
			}
		}
		else
		{
			tmpRecPtr = targetPagePtr + pageHeaderSize;
			break;
		}
	}

	/*
	 * we know now that tmpRecPtr is an address pointing to a valid XLogRecord
	 * because either we're at the first record after the beginning of a page
	 * or we just jumped over the remaining data of a continuation.
	 */
	XLogBeginRead(state, tmpRecPtr);
	while (XLogReadRecord(state, &errormsg) != NULL)
	{
		/* past the record we've found, break out */
		if (RecPtr <= state->ReadRecPtr)
		{
			/* Rewind the reader to the beginning of the last record. */
			found = state->ReadRecPtr;
			XLogBeginRead(state, found);
			return found;
		}
	}

err:
	XLogReaderInvalReadState(state);

	return InvalidXLogRecPtr;
}

fn main() {
    let args = Cli::parse();
    let mut private = XLogDumpPrivate::new();
    private.timeline = args.timeline.unwrap();

    let mut waldir = std::path::PathBuf::new();
    if let Some(path) = args.path {
        waldir = path;
    }

    if let Some(startseg) = args.startseg {
        let mut segno: XLogSegNo = 0;

        let fname = startseg.file_name().unwrap().into();
        if let Some(dir) = startseg.parent() {
            if waldir.as_os_str().is_empty() {
                waldir = dir.to_path_buf();
            }
        }
        waldir = identify_target_directory(waldir, &fname);
        println!("Bytes per WAL segment: {}", unsafe_get_wal_seg_sz());

        // parse position from file
        xlog_from_file_name(
            &fname,
            &mut private.timeline,
            &mut segno,
            unsafe_get_wal_seg_sz(),
        );

        match args.start {
            Some(start) => {
                if start / unsafe_get_wal_seg_sz() as u64 != segno {
                    panic!("start WAL location {} is not in file {}", start, segno);
                }
                private.startptr = start;
            }
            None => {
                private.startptr = segno * unsafe_get_wal_seg_sz() as u64;
            }
        }

        if let Some(endseg) = args.endseg {
            let fname: PathBuf = endseg.file_name().unwrap().into();
            let fpath = PathBuf::from(&waldir).join(&fname);
            if std::fs::File::open(fpath).is_err() {
                panic!("could not open file {}", endseg.display());
            }

            let mut endsegno: XLogSegNo = 0;
            xlog_from_file_name(
                &fname,
                &mut private.timeline,
                &mut endsegno,
                unsafe_get_wal_seg_sz(),
            );
            if endsegno < segno {
                panic!("ENDSEG {} is before STARTSEG {}", endsegno, segno);
            }
            match args.end {
                Some(end) => {
                    if end / unsafe_get_wal_seg_sz() as u64 != endsegno {
                        panic!(
                            "end WAL location {} is not in file {}",
                            end,
                            fname.display()
                        );
                    }
                    private.endptr = end;
                }
                None => {
                    private.endptr = (endsegno + 1) * unsafe_get_wal_seg_sz() as u64;
                }
            }
        }
    } else {
        waldir = identify_target_directory(waldir, &PathBuf::new());
    }

    if private.startptr == XLOG_INVALID_RECPTR {
        panic!("no start WAL location given");
    }

    let xlogreader_state = XLogReaderState::default();
    first_record = xlog_find_next_record(xlogreader_state, private.startptr);

    loop {
        xlog_read_record();
        xlog_show_record();
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    const WAL_FILE: &[u8] = include_bytes!("../test/000000010000000000000001");

    #[test]
    fn test_page_header() {
        #[rustfmt::skip]
        let input = [
            0x10, 0xD1, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ];
        let (_, hdr) = page_header(&input).unwrap();
        assert_eq!(hdr.xlp_magic, XLOG_PAGE_MAGIC);
        assert_eq!(hdr.xlp_info, XLP_LONG_HEADER);
        assert_eq!(hdr.xlp_tli, 1);
        assert_eq!(hdr.xlp_paguaddr, 0x01000000);
        assert_eq!(hdr.xlp_rem_len, 0);
    }

    #[test]
    fn wal_file_first_page_header() {
        let (_, hdr) = first_page_header(WAL_FILE).unwrap();
        assert_eq!(hdr.std.xlp_magic, XLOG_PAGE_MAGIC);
        assert_eq!(hdr.std.xlp_info, XLP_LONG_HEADER);
        assert_eq!(hdr.std.xlp_tli, 1);
        assert_eq!(hdr.std.xlp_paguaddr, 0x01000000);
        assert_eq!(hdr.std.xlp_rem_len, 0);
        assert_eq!(hdr.xlp_sysid, 0x657d48e8d9177b4b);
        assert_eq!(hdr.xlp_seg_size, 16 * 1024 * 1024);
        assert_eq!(hdr.xlp_xlog_blcksz, 8 * 1024);
    }

    #[test]
    fn test_xlog_record() {
        #[rustfmt::skip]
        let input = [
            0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x8a, 0xff, 0xa2, 0x51,
        ];
        let (_, xlog) = xlog_record(&input).unwrap();
        assert_eq!(xlog.xl_tot_len, 114);
        assert_eq!(xlog.xl_xid, 0);
        assert_eq!(xlog.xl_prev, 0);
        assert_eq!(xlog.xl_info, 0);
        assert_eq!(xlog.xl_rmid, 0);
        assert_eq!(xlog.xl_crc, 0x51a2ff8a);
    }

    #[test]
    fn test_xlog_record_data_header_short() {
        #[rustfmt::skip]
        let input = [
            0xff, 0x00,
        ];
        let (_, hdr) = xlog_record_data_header(&input).unwrap();
        assert_eq!(
            hdr,
            XLogRecordDataHeader::Short(XLogRecordDataHeaderShort {
                id: 0xff,
                data_length: 0,
            })
        );
    }

    #[test]
    fn test_xlog_record_data_header_long() {
        #[rustfmt::skip]
        let input = [
            0xfe, 0x01, 0x02, 0x03, 0x04,
        ];
        let (_, hdr) = xlog_record_data_header(&input).unwrap();
        assert_eq!(
            hdr,
            XLogRecordDataHeader::Long(XLogRecordDataHeaderLong {
                id: 0xfe,
                data_length: 0x04030201,
            })
        );
    }

    #[test]
    fn test_xlog_record_data_header_origin() {
        #[rustfmt::skip]
        let input = [
            0xfd, 0x01, 0x02,
        ];
        let (_, hdr) = xlog_record_data_header(&input).unwrap();
        assert_eq!(
            hdr,
            XLogRecordDataHeader::Origin(XLogRecordDataHeaderOrigin {
                id: 0xfd,
                record_origin: 0x0201,
            })
        );
    }

    #[test]
    fn test_xlog_record_data_header_top_level_xid() {
        #[rustfmt::skip]
        let input = [
            0xfc, 0x01, 0x02, 0x03, 0x04,
        ];
        let (_, hdr) = xlog_record_data_header(&input).unwrap();
        assert_eq!(
            hdr,
            XLogRecordDataHeader::TopLevelXid(XLogRecordDataHeaderTopLevelXid {
                id: 0xfc,
                top_level_xid: 0x04030201,
            })
        );
    }

    #[test]
    fn test_xlog_record_block_header() {
        #[rustfmt::skip]
        let input = [
            0x01, 0x02, 0x03, 0x04,
        ];
        let (_, hdr) = xlog_record_data_header(&input).unwrap();
        assert_eq!(
            hdr,
            XLogRecordDataHeader::Block(XLogRecordBlockHeader {
                id: 0x01,
                fork_flags: 0x02,
                data_length: 0x0403,
            })
        );
    }

    #[test]
    fn wal_file_parse() {
        let (remaining, long_hdr) = first_page_header(WAL_FILE).unwrap();
        let (remaining, xlog_rrd) = xlog_record(remaining).unwrap();
        let (remaining, data_hdr) = xlog_record_data_header(remaining).unwrap();
        assert_eq!(
            data_hdr,
            XLogRecordDataHeader::Short(XLogRecordDataHeaderShort {
                id: 0xff,
                data_length: 0x58,
            })
        );
        let data_hdr = match data_hdr {
            XLogRecordDataHeader::Short(hdr) => hdr,
            _ => panic!("unexpected data header"),
        };
        assert_eq!(
            xlog_rrd.xl_tot_len as usize,
            data_hdr.data_length as usize
                + std::mem::size_of::<XLogRecord>()
                + std::mem::size_of::<XLogRecordDataHeaderShort>()
        );
        let info = xlog_rrd.xl_info & XLR_RMGR_INFO_MASK;
        assert_eq!(info, XLogRmgrId::CheckpointShutdown as u8);
        assert_eq!(
            data_hdr.data_length as usize,
            std::mem::size_of::<CheckPoint>()
        );

        let ckp: CheckPoint = unsafe { std::ptr::read(remaining.as_ptr() as *const CheckPoint) };
        println!("{}", ckp);
    }
}
