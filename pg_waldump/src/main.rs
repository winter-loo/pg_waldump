#![allow(unused)]
use core::arch;
use nom::bytes::streaming::take as bytes_take;
use nom::combinator::map;
use nom::number::streaming::{le_u16, le_u32, le_u64, le_u8};
use nom::sequence;
use nom::IResult;
use std::mem::size_of;
mod constant;
use constant::*;
mod pg_types;
use pg_types::*;
use std::path::PathBuf;

use clap::Parser;

/// pg_waldump decodes and displays PostgreSQL write-ahead logs for debugging.
#[derive(Parser)]
#[command(author, version, about, long_about = None, disable_colored_help=true,
help_template="\
{about-with-newline}
{usage-heading}
  {bin} [OPTIONS] [STARTSEG [ENDSEG]]

Options:
{options}
")]
struct Cli {
    startseg: Option<String>,
    endseg: Option<String>,

    /// output detailed information about backup blocks
    #[arg(short, long, action=clap::ArgAction::SetTrue)]
    bkp_details: Option<bool>,

    /// with --relation, only show records that modify block N
    #[arg(short = 'B', long, value_name = "N")]
    block: Option<u32>,

    /// start reading at WAL location RECPTR
    #[arg(short, long, value_name = "RECPTR")]
    start: Option<String>,

    /// stop reading at WAL location RECPTR
    #[arg(short, long, value_name = "RECPTR")]
    end: Option<String>,

    /// keep retrying after reaching end of WAL
    #[arg(short, long, action=clap::ArgAction::SetTrue)]
    follow: Option<bool>,

    #[arg(
        short = 'F',
        long,
        value_name = "FORK",
        value_parser=[
            "main",
            "fsm",
            "vm",
            "init",
        ],
        hide_possible_values=true,
        help = "\
only show records that modify blocks in fork FORK;
valid names are main, fsm, vm, init"
    )]
    fork: Option<String>,

    /// number of records to display
    #[arg(short = 'n', long, value_name = "N")]
    limit: Option<u32>,

    #[arg(
        short,
        long,
        default_values=[
            ".",
            "./pg_wal",
            "$PGDATA/pg_wal",
        ],
        hide_default_value=true,
        help = "\
directory in which to find log segment files or a
directory with a ./pg_wal that contains such files
(default: current directory, ./pg_wal, $PGDATA/pg_wal)"
    )]
    path: Option<String>,

    /// do not print any output, except for errors
    #[arg(short, long, action=clap::ArgAction::SetTrue)]
    quiet: Option<bool>,

    #[arg(
        short,
        long,
        help = "\
only show records generated by resource manager RMGR;
use --rmgr=list to list valid resource manager names"
    )]
    rmgr: Option<String>,

    /// only show records that modify blocks in relation T/D/R
    #[arg(short = 'R', long, value_name = "T/D/R")]
    relation: Option<String>,

    #[arg(
        short,
        long,
        value_name = "TLI",
        help = "\
timeline from which to read log records
(default: 1 or the value used in STARTSEG)"
    )]
    timeline: Option<String>,

    /// only show records with a full page write
    #[arg(short='w', long, action=clap::ArgAction::SetTrue)]
    fullpage: Option<bool>,

    /// only show records with transaction ID XID
    #[arg(short, long)]
    xid: Option<String>,

    #[arg(
        short = 'z',
        long,
        value_name = "record",
        help = "\
show statistics instead of records
(optionally, show per-record statistics)"
    )]
    // this is an optional argument and the argument value is also optional
    stats: Option<Option<String>>,
}

#[repr(align(8))]
struct XLogPageHeaderData {
    xlp_magic: u16,
    xlp_info: u16,
    xlp_tli: TimeLineID,
    xlp_paguaddr: XLogRecPtr,
    // When there is not enough space on current page for whole record, we
    // continue on the next page.  xlp_rem_len is the number of bytes
    // remaining from a previous page.
    //
    // Note that xlp_rem_len includes backup-block data; that is, it tracks
    // xl_tot_len not xl_len in the initial header.  Also note that the
    // continuation data isn't necessarily aligned.
    xlp_rem_len: u32,
}

impl XLogPageHeaderData {
    fn new() -> Self {
        XLogPageHeaderData {
            xlp_magic: XLOG_PAGE_MAGIC,
            xlp_info: 0,
            xlp_tli: 0,
            xlp_paguaddr: 0,
            xlp_rem_len: 0,
        }
    }
}

fn page_header(input: &[u8]) -> IResult<&[u8], XLogPageHeaderData> {
    map(
        sequence::tuple((le_u16, le_u16, le_u32, le_u64, le_u32, bytes_take(4usize))),
        |(magic, info, tli, paguaddr, rem_len, _)| {
            if magic != XLOG_PAGE_MAGIC {
                panic!("invalid magic: {:#06X}", magic);
            }
            XLogPageHeaderData {
                xlp_magic: XLOG_PAGE_MAGIC,
                xlp_info: info,
                xlp_tli: tli,
                xlp_paguaddr: paguaddr,
                xlp_rem_len: rem_len,
            }
        },
    )(input)
}

#[repr(align(8))]
struct XLogLongPageHeaderData {
    std: XLogPageHeaderData,
    xlp_sysid: u64,
    xlp_seg_size: u32,
    xlp_xlog_blcksz: u32,
}

fn first_page_header(input: &[u8]) -> IResult<&[u8], XLogLongPageHeaderData> {
    map(
        sequence::tuple((page_header, le_u64, le_u32, le_u32)),
        |(hdr, sysid, seg_size, blcksz)| XLogLongPageHeaderData {
            std: hdr,
            xlp_sysid: sysid,
            xlp_seg_size: seg_size,
            xlp_xlog_blcksz: blcksz,
        },
    )(input)
}

#[repr(align(8))]
struct XLogRecord {
    // total len of entire record
    xl_tot_len: u32,
    // xact id
    xl_xid: TransactionId,
    // ptr to previous record in log
    xl_prev: XLogRecPtr,
    // flag bits, see below
    xl_info: u8,
    // resource manager for this record
    xl_rmid: RmgrId,
    // CRC for this record
    xl_crc: PgCrc32c,
    // XLogRecordBlockHeaders and XLogRecordDataHeader follow, no padding
}

fn xlog_record(input: &[u8]) -> IResult<&[u8], XLogRecord> {
    map(
        sequence::tuple((
            le_u32,
            le_u32,
            le_u64,
            le_u8,
            le_u8,
            bytes_take(2usize),
            le_u32,
        )),
        |(tot_len, xid, prev, info, rmid, _, crc)| XLogRecord {
            xl_tot_len: tot_len,
            xl_xid: xid,
            xl_prev: prev,
            xl_info: info,
            xl_rmid: rmid,
            xl_crc: crc,
        },
    )(input)
}

#[derive(PartialEq, Debug)]
enum XLogRecordDataHeader {
    Short(XLogRecordDataHeaderShort),
    Long(XLogRecordDataHeaderLong),
    Origin(XLogRecordDataHeaderOrigin),
    TopLevelXid(XLogRecordDataHeaderTopLevelXid),
    Block(XLogRecordBlockHeader),
}

fn xlog_record_data_header(input: &[u8]) -> IResult<&[u8], XLogRecordDataHeader> {
    let (input, id) = le_u8(input)?;
    match id {
        XLR_BLOCK_ID_DATA_SHORT => map(xlog_record_data_header_short(id), |hdr| {
            XLogRecordDataHeader::Short(hdr)
        })(input),
        XLR_BLOCK_ID_DATA_LONG => map(xlog_record_data_header_long(id), |hdr| {
            XLogRecordDataHeader::Long(hdr)
        })(input),
        XLR_BLOCK_ID_ORIGIN => map(xlog_record_data_header_origin(id), |hdr| {
            XLogRecordDataHeader::Origin(hdr)
        })(input),
        XLR_BLOCK_ID_TOPLEVEL_XID => map(xlog_record_data_header_top_level_xid(id), |hdr| {
            XLogRecordDataHeader::TopLevelXid(hdr)
        })(input),
        val if val <= XLR_MAX_BLOCK_ID => map(xlog_record_block_header(id), |hdr| {
            XLogRecordDataHeader::Block(hdr)
        })(input),
        _ => panic!("invalid XLogRecordDataHeader id: {}", id),
    }
}

// XLogRecordDataHeaderShort/Long are used for the "main data" portion of
// the record. If the length of the data is less than 256 bytes, the short
// form is used, with a single byte to hold the length. Otherwise the long
// form is used.
#[repr(packed)]
#[derive(PartialEq, Debug)]
struct XLogRecordDataHeaderShort {
    // XLR_BLOCK_ID_DATA_SHORT
    id: u8,
    // number of payload bytes
    data_length: u8,
}

fn xlog_record_data_header_short(
    id: u8,
) -> impl FnMut(&[u8]) -> IResult<&[u8], XLogRecordDataHeaderShort> {
    move |input: &[u8]| {
        let (input, data_length) = le_u8(input)?;
        Ok((input, XLogRecordDataHeaderShort { id, data_length }))
    }
}

#[repr(packed)]
#[derive(PartialEq, Debug)]
struct XLogRecordDataHeaderLong {
    // XLR_BLOCK_ID_DATA_LONG
    id: u8,
    data_length: u32,
}

fn xlog_record_data_header_long(
    id: u8,
) -> impl FnMut(&[u8]) -> IResult<&[u8], XLogRecordDataHeaderLong> {
    move |input: &[u8]| {
        let (input, data_length) = le_u32(input)?;
        Ok((input, XLogRecordDataHeaderLong { id, data_length }))
    }
}

#[repr(packed)]
#[derive(PartialEq, Debug)]
struct XLogRecordDataHeaderOrigin {
    id: u8,
    record_origin: u16,
}

fn xlog_record_data_header_origin(
    id: u8,
) -> impl FnMut(&[u8]) -> IResult<&[u8], XLogRecordDataHeaderOrigin> {
    move |input: &[u8]| {
        let (input, record_origin) = le_u16(input)?;
        Ok((input, XLogRecordDataHeaderOrigin { id, record_origin }))
    }
}

#[repr(packed)]
#[derive(PartialEq, Debug)]
struct XLogRecordDataHeaderTopLevelXid {
    id: u8,
    top_level_xid: TransactionId,
}

fn xlog_record_data_header_top_level_xid(
    id: u8,
) -> impl FnMut(&[u8]) -> IResult<&[u8], XLogRecordDataHeaderTopLevelXid> {
    move |input: &[u8]| {
        let (input, top_level_xid) = le_u32(input)?;
        Ok((input, XLogRecordDataHeaderTopLevelXid { id, top_level_xid }))
    }
}

// Header info for block data appended to an XLOG record.
//
// 'data_length' is the length of the rmgr-specific payload data associated
// with this block. It does not include the possible full page image, nor
// XLogRecordBlockHeader struct itself.
//
// Note that we don't attempt to align the XLogRecordBlockHeader struct!
// So, the struct must be copied to aligned local storage before use.
///
#[repr(packed)]
#[derive(PartialEq, Debug)]
struct XLogRecordBlockHeader {
    // block reference ID
    id: u8,
    // fork within the relation, and flags
    fork_flags: u8,
    // number of payload bytes (not including page image)
    data_length: u16,
    // If BKPBLOCK_HAS_IMAGE, an XLogRecordBlockImageHeader struct follows
    // If BKPBLOCK_SAME_REL is not set, a RelFileNode follows
    // BlockNumber follows
}

fn xlog_record_block_header(id: u8) -> impl FnMut(&[u8]) -> IResult<&[u8], XLogRecordBlockHeader> {
    move |input: &[u8]| {
        map(
            sequence::tuple((le_u8, le_u16)),
            |(fork_flags, data_length)| XLogRecordBlockHeader {
                id,
                fork_flags,
                data_length,
            },
        )(input)
    }
}

struct RelFileNode {
    // tablespace
    spc_node: u32,
    // database
    db_node: u32,
    // relation
    rel_node: u32,
}

fn rel_file_node(input: &[u8]) -> IResult<&[u8], RelFileNode> {
    map(
        sequence::tuple((le_u32, le_u32, le_u32)),
        |(spc_node, db_node, rel_node)| RelFileNode {
            spc_node,
            db_node,
            rel_node,
        },
    )(input)
}

#[repr(packed)]
struct XLogRecordBlockImageHeader {
    // number of page image bytes
    length: u16,
    // number of bytes before "hole"
    hole_offset: u16,
    // flag bits, see below
    bimg_info: u8,
    // If BKPIMAGE_HAS_HOLE and BKPIMAGE_IS_COMPRESSED, an
    // XLogRecordBlockCompressHeader struct follows.
}

fn xlog_record_block_image_header(input: &[u8]) -> IResult<&[u8], XLogRecordBlockImageHeader> {
    map(
        sequence::tuple((le_u16, le_u16, le_u8)),
        |(length, hole_offset, bimg_info)| XLogRecordBlockImageHeader {
            length,
            hole_offset,
            bimg_info,
        },
    )(input)
}

fn xlog_block_number(input: &[u8]) -> IResult<&[u8], BlockNumber> {
    le_u32(input)
}

struct XLogRecordBlockCompressHeader {
    // number of bytes in "hole"
    hole_length: u16,
}

fn xlog_page_header_size(hdr: XLogPageHeaderData) -> usize {
    if hdr.xlp_info & XLP_LONG_HEADER != 0 {
        size_of::<XLogLongPageHeaderData>()
    } else {
        size_of::<XLogPageHeaderData>()
    }
}

fn main() {
    let args = Cli::parse();

    if let Some(startseg) = args.startseg {
        println!("startseg: {}", startseg);
    }

    if let Some(endarg) = args.endseg {
        println!("endseg: {}", endarg);
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    const WAL_FILE: &[u8] = include_bytes!("../test/wal_segment");

    #[test]
    fn test_page_header() {
        #[rustfmt::skip]
        let input = [
            0x10, 0xD1, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ];
        let (_, hdr) = page_header(&input).unwrap();
        assert_eq!(hdr.xlp_magic, XLOG_PAGE_MAGIC);
        assert_eq!(hdr.xlp_info, XLP_LONG_HEADER);
        assert_eq!(hdr.xlp_tli, 1);
        assert_eq!(hdr.xlp_paguaddr, 0x01000000);
        assert_eq!(hdr.xlp_rem_len, 0);
    }

    #[test]
    fn wal_file_first_page_header() {
        let (_, hdr) = first_page_header(WAL_FILE).unwrap();
        assert_eq!(hdr.std.xlp_magic, XLOG_PAGE_MAGIC);
        assert_eq!(hdr.std.xlp_info, XLP_LONG_HEADER);
        assert_eq!(hdr.std.xlp_tli, 1);
        assert_eq!(hdr.std.xlp_paguaddr, 0x01000000);
        assert_eq!(hdr.std.xlp_rem_len, 0);
        assert_eq!(hdr.xlp_sysid, 0x657d48e8d9177b4b);
        assert_eq!(hdr.xlp_seg_size, 16 * 1024 * 1024);
        assert_eq!(hdr.xlp_xlog_blcksz, 8 * 1024);
    }

    #[test]
    fn test_xlog_record() {
        #[rustfmt::skip]
        let input = [
            0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x8a, 0xff, 0xa2, 0x51,
        ];
        let (_, xlog) = xlog_record(&input).unwrap();
        assert_eq!(xlog.xl_tot_len, 114);
        assert_eq!(xlog.xl_xid, 0);
        assert_eq!(xlog.xl_prev, 0);
        assert_eq!(xlog.xl_info, 0);
        assert_eq!(xlog.xl_rmid, 0);
        assert_eq!(xlog.xl_crc, 0x51a2ff8a);
    }

    #[test]
    fn test_xlog_record_data_header_short() {
        #[rustfmt::skip]
        let input = [
            0xff, 0x00,
        ];
        let (_, hdr) = xlog_record_data_header(&input).unwrap();
        assert_eq!(
            hdr,
            XLogRecordDataHeader::Short(XLogRecordDataHeaderShort {
                id: 0xff,
                data_length: 0,
            })
        );
    }

    #[test]
    fn test_xlog_record_data_header_long() {
        #[rustfmt::skip]
        let input = [
            0xfe, 0x01, 0x02, 0x03, 0x04,
        ];
        let (_, hdr) = xlog_record_data_header(&input).unwrap();
        assert_eq!(
            hdr,
            XLogRecordDataHeader::Long(XLogRecordDataHeaderLong {
                id: 0xfe,
                data_length: 0x04030201,
            })
        );
    }

    #[test]
    fn test_xlog_record_data_header_origin() {
        #[rustfmt::skip]
        let input = [
            0xfd, 0x01, 0x02,
        ];
        let (_, hdr) = xlog_record_data_header(&input).unwrap();
        assert_eq!(
            hdr,
            XLogRecordDataHeader::Origin(XLogRecordDataHeaderOrigin {
                id: 0xfd,
                record_origin: 0x0201,
            })
        );
    }

    #[test]
    fn test_xlog_record_data_header_top_level_xid() {
        #[rustfmt::skip]
        let input = [
            0xfc, 0x01, 0x02, 0x03, 0x04,
        ];
        let (_, hdr) = xlog_record_data_header(&input).unwrap();
        assert_eq!(
            hdr,
            XLogRecordDataHeader::TopLevelXid(XLogRecordDataHeaderTopLevelXid {
                id: 0xfc,
                top_level_xid: 0x04030201,
            })
        );
    }

    #[test]
    fn test_xlog_record_block_header() {
        #[rustfmt::skip]
        let input = [
            0x01, 0x02, 0x03, 0x04,
        ];
        let (_, hdr) = xlog_record_data_header(&input).unwrap();
        assert_eq!(
            hdr,
            XLogRecordDataHeader::Block(XLogRecordBlockHeader {
                id: 0x01,
                fork_flags: 0x02,
                data_length: 0x0403,
            })
        );
    }

    #[test]
    fn wal_file_parse() {
        let (remaining, long_hdr) = first_page_header(WAL_FILE).unwrap();
        let (remaining, xlog_rrd) = xlog_record(remaining).unwrap();
        let (remaining, data_hdr) = xlog_record_data_header(remaining).unwrap();
        assert_eq!(
            data_hdr,
            XLogRecordDataHeader::Short(XLogRecordDataHeaderShort {
                id: 0xff,
                data_length: 0x58,
            })
        );
        let data_hdr = match data_hdr {
            XLogRecordDataHeader::Short(hdr) => hdr,
            _ => panic!("unexpected data header"),
        };
        assert_eq!(
            xlog_rrd.xl_tot_len as usize,
            data_hdr.data_length as usize
                + std::mem::size_of::<XLogRecord>()
                + std::mem::size_of::<XLogRecordDataHeaderShort>()
        );
        let info = xlog_rrd.xl_info & XLR_RMGR_INFO_MASK;
        assert_eq!(info, XLogRmgrId::CheckpointShutdown as u8);
        assert_eq!(
            data_hdr.data_length as usize,
            std::mem::size_of::<CheckPoint>()
        );

        let ckp: CheckPoint = unsafe { std::ptr::read(remaining.as_ptr() as *const CheckPoint) };
        println!("{}", ckp);
    }
}
